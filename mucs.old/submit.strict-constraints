#!/usr/bin/env python3
# vim: foldmethod=marker

"""Test."""

import calendar
import hashlib
import json
import os
import re
import subprocess
import sys
from _strptime import _strptime
from datetime import datetime, time
from getpass import getpass, getuser
from termios import ECHO, ICANON, TCSADRAIN, tcgetattr, tcsetattr

RESET = '\33[0m'
GREEN = '\33[92m'
RED = '\33[91m'
_BOLD = '\33[1m'

NOW = datetime.now()
WEEKDAY = NOW.weekday()


##################################################
# Utils
##################################################


# Util Functions {{{
def BOLD(x):
    return _BOLD + x + RESET


def err_msg(*messages, color=RED, end='\n'):
    print(color + ' '.join(messages) + RESET, end=end)


def error(*messages, color=RED):
    err_msg(*messages, color=color)
    sys.exit(1)


def usage():
    usage = '\n'.join([
        'Usage: submit <course> <assignment> <file>',
        '       submit DOWNLOAD <file>',
        '       submit ADMIN'])
    error(usage, color='')


def file_exists(fn):
    try:
        open(fn, 'r').close()
    except OSError:
        return False
    else:
        return True


def file_compiles(fn):
    if subprocess.call(['compile', fn]) == 0:
        os.remove('a.out')
        return True
    else:
        return False


def clear_screen():
    """Clear the terminal."""
    subprocess.run(['clear'])


def modify_volatile(key, value):
    with open('volatile', 'r') as volatile_f:
        old_volatile = volatile_f.read()

    old_val = repr(globals()[key])
    new_val = repr(value)

    new_volatile = re.sub(
        '%s = %s' % (key, old_val),
        '%s = %s' % (key, new_val),
        old_volatile)

    with open('volatile', 'w') as volatile_f:
        volatile_f.write(new_volatile)


def write_json(fn, data):
    with open(fn, 'w') as f:
        f.write(json.dumps(data, indent=4) + '\n')


def md5(msg):
    """Return the hex digest of a md5-hashed string."""
    return hashlib.md5(msg.encode()).hexdigest()
# }}}


# Date and Time Classes and Functions {{{
def to_month(string):
    try:
        month = int(string)
        if 1 <= month <= 12:
            return month
        else:
            return None
    except ValueError:
        if string in calendar.month_abbr[1:]:
            return calendar.month_abbr.index(string)
        elif string in calendar.month_name[1:]:
            return calendar.month_name.index(string)
        else:
            return None


class Time(time):
    def __new__(self, fmt):
        fmt_err = "Expected format '%%d%%d:%%d%%d:%%d%%d' but got '%s'" % fmt

        pieces = fmt.split(':')
        if len(pieces) != 3:
            raise ValueError(fmt_err)

        try:
            fields = {
                'hour': int(pieces[0]),
                'minute': int(pieces[1]),
                'second': int(pieces[2])}
        except ValueError:
            raise ValueError(fmt_err)

        return super().__new__(self, **fields)

    def __str__(self):
        return self.strftime('%I:%M:%S %p')

    def __repr__(self):
        return self.strftime('%H:%M:%S')


class DueDate(datetime):
    def __new__(self, string):
        tt = _strptime(string, '%Y-%m-%dT%H:%M:%S')[0]
        return super().__new__(self, *tt[:6])

    def __str__(self):
        return self.strftime('%Y %b %d, %I:%M:%S %p')

    def __repr__(self):
        return self.strftime('%Y-%m-%dT%H:%M:%S')


class TimePeriod:
    """Contain the start and end times for an assignment."""

    def __init__(self, start, end):
        self.start = Time(start)
        self.end = Time(end)

    def __contains__(self, now):
        if not isinstance(now, datetime):
            return False
        if self.start <= now <= self.end:
            return True
        else:
            return False

    def __repr__(self):
        return '%s(start=%s, end=%s)' % (self.__class__.__name__,
                                         str(self.start), str(self.end))

    def __str__(self):
        return str(self.start) + ' - ' + str(self.end)
# }}}


##################################################
# User Input
##################################################


# {{{


# listbox {{{
def listbox(title, choices, cursor='*', clear=True, show_instructions=True):
    """Return the user's choice from a text-only listbox.
    Example:
        >>> title = 'The Title'
        >>> choices = ['a', 'b', 'c']
        >>> listbox(title, choices, clear=False, show_instructions=False)
          The Title
          ---------
        * a
          b
          c
    """
    def draw():
        # Put the cursor in front of the current selection
        for i, elem in enumerate(choices):
            if i == current:
                print(cursor + ' ', end='')
            else:
                print(' ' * (len(cursor)+1), end='')
            print(elem)

    def reset():
        print('\33[A\33[2K' * len(choices), end='')

    if clear:
        clear_screen()

    if show_instructions:
        print('Press k/j or up/down arrow to move up and down.')
        print('Press K/J to go to the top and bottom.')
        print('Press q to quit.')
        print('Press Enter to confirm the selection.')
        print()

    if title:
        print(' ' * (len(cursor)+1), end='')
        print(title)
        print(' ' * (len(cursor)+1), end='')
        print('-' * len(title))

    fd = sys.stdin.fileno()

    old_settings = tcgetattr(fd)
    new_settings = tcgetattr(fd)
    new_settings[3] &= ~(ECHO | ICANON)
    tcsetattr(fd, TCSADRAIN, new_settings)

    current = 0
    choice = None
    quit = False
    draw()

    while True:
        redraw = False

        c = sys.stdin.read(1)
        if c in ('k', 'A'):
            if current > 0:
                current -= 1
                redraw = True
        elif c == 'K':
            current = 0
            redraw = True
        elif c in ('j', 'B'):
            if current < len(choices)-1:
                current += 1
                redraw = True
        elif c == 'J':
            current = len(choices) - 1
            redraw = True
        elif c == '\n':
            choice = current
            quit = True
        elif c == 'q':
            quit = True

        if quit:
            break

        if redraw:
            reset()
            draw()

    tcsetattr(fd, TCSADRAIN, old_settings)

    return choice
# }}}


# menu {{{
def menu(title, choices, cursor='*', clear=True, show_instructions=True,
         select_hook=None, add_hook=None, save_hook=None):
    local_vars = locals()
    for hook_name in ('select', 'add', 'save'):
        if local_vars[hook_name+'_hook'] is None:
            raise ValueError('keyword argument must be specified: %s_hook' %
                             hook_name)
        if not callable(local_vars[hook_name+'_hook']):
            raise ValueError('keyword argument must be callable: %s_hook' %
                             hook_name)

    MODE_SELECT = 0
    MODE_ADD = 1
    MODE_DELETE = 2
    mode = MODE_SELECT

    def instructions():
        if not show_instructions:
            return
        print('Press k/j or up/down arrow to move up and down.')
        print('Press K/J to go to the top and bottom.')
        print('Press q to quit.')
        print()
        print('Press Enter to modify.')
        print('Press a to add.')
        print('Press d to delete.')
        print('Press s to save.')
        print('Press ESC to exit a mode.')
        print()

    def show_title():
        if not title:
            return
        print(' ' * len(cursor), title)
        print(' ' * len(cursor), '-' * len(title))

    def draw(reset=True):
        if reset:
            print('\r\33[2K', end='')
            print('\33[A\33[2K' * n_lines, end='')

        if mode == MODE_ADD:
            printed_add_cursor = False
            for i, elem in enumerate(choices):
                if i == current:
                    print(cursor + ' <INSERT HERE>')
                    printed_add_cursor = True
                print(' ' * len(cursor), elem)
            if not printed_add_cursor:
                print(cursor + ' <INSERT HERE>')
        else:
            for i, elem in enumerate(choices):
                if i == current:
                    print(cursor + ' ', end='')
                else:
                    print(' ' * (len(cursor)+1), end='')
                print(elem)

    if clear:
        clear_screen()

    instructions()
    show_title()

    fd = sys.stdin.fileno()

    old_settings = tcgetattr(fd)
    new_settings = tcgetattr(fd)
    new_settings[3] &= ~(ECHO | ICANON)
    tcsetattr(fd, TCSADRAIN, new_settings)

    n_lines = len(choices)
    old_cursor = None
    quit = False
    unsaved_changes = False
    current = 0
    draw(reset=False)

    while True:
        if mode == MODE_SELECT:
            n_lines = len(choices)
        elif mode == MODE_ADD:
            n_lines = len(choices) + 1

        c = sys.stdin.read(1)

        if c == 'q':
            print()
            break

        elif c in ('k', 'A'):
            if current > 0:
                current -= 1
                draw()

        elif c in ('j', 'B'):
            if current < n_lines - 1:
                current += 1
                draw()

        elif c == 'K':
            current = 0
            draw()

        elif c == 'J':
            current = n_lines - 1
            draw()

        elif c == '\n':
            if mode in (MODE_SELECT, MODE_ADD):
                # Temporarily reset settings for user input
                tcsetattr(fd, TCSADRAIN, old_settings)
                if mode == MODE_SELECT:
                    choices[current] = select_hook()
                elif mode == MODE_ADD:
                    choices.insert(current, add_hook())
                tcsetattr(fd, TCSADRAIN, new_settings)
                # Setup the menu again
                clear_screen()
                instructions()
                show_title()
                mode = MODE_SELECT
                current = 0
                draw(reset=False)
            elif mode == MODE_DELETE:
                del choices[current]
                mode = MODE_SELECT
                cursor = old_cursor
                current = 0
                mode = MODE_SELECT
                draw()
            unsaved_changes = True

        elif c == '\33':
            if mode == MODE_DELETE:
                cursor = old_cursor
            mode = MODE_SELECT
            current = 0
            draw()

        elif c == 'a' and mode == MODE_SELECT:
            mode = MODE_ADD
            current = 0
            draw()

        elif c == 'd' and mode == MODE_SELECT:
            mode = MODE_DELETE
            old_cursor = cursor
            cursor = 'X'
            draw()

        elif c == 's' and unsaved_changes:
            save_hook(choices)
            unsaved_changes = False
            print(GREEN, 'Done', RESET, ' ', sep='', end='', flush=True)

    tcsetattr(fd, TCSADRAIN, old_settings)
# }}}


def get_int(prompt, minimum, maximum):
    while True:
        try:
            num = int(input(prompt))
            if minimum <= num <= maximum:
                return num
        except ValueError:
            pass


def get_month():
    while True:
        user_in = input('Month (1..12/Jan..Dec/January..December): ')
        month = to_month(user_in)
        if month is not None:
            return month


def get_day(month):
    ndays = calendar.mdays[month]
    return get_int('Day (1..%d): ' % ndays, 1, ndays)


def get_hour(prompt):
    return get_int(prompt, 0, 23)


def get_minute(prompt):
    return get_int(prompt, 0, 59)


def get_second(prompt):
    return get_minute(prompt)


def get_session_letter(*exception):
    return input('Lab session letter: ').upper()


def get_weekday():
    return get_int('Weekday (0..6): ', 0, 6)


def get_hw_name():
    return input('Homework Name: ').upper()


# }}}


##################################################
# Model
##################################################


# {{{


class LabSession:
    def __init__(self, letter, weekday, timeperiod):
        if weekday not in range(7):
            raise ValueError('Weekdays must be an integer from 0 to 6')

        self.letter = letter
        self.weekday = weekday
        self._timeperiod = timeperiod
        self.start = timeperiod.start
        self.end = timeperiod.end

    def __contains__(self, other):
        if not isinstance(other, datetime):
            raise ValueError("Cannot compare type '%s' with type '%s'" %
                             (other.__class__.__name__,
                              self.__class__.__name__))
        if self.start <= other.time() <= self.end:
            return True
        else:
            return False

    def __str__(self):
        wd = list(calendar.day_name)[self.weekday]
        return '%s (%ss, %s)' % (self.letter, wd, self._timeperiod)

    def __repr__(self):
        return self.__str__()


class Homework:
    def __init__(self, name, duedate):
        self.name = name
        self.duedate = duedate

    def __str__(self):
        return '%s (%s)' % (self.name, self.duedate)

    def __repr__(self):
        return self.__str__()


def setup():
    global USERNAME, SESSIONS_FN, HWS_FN

    USERNAME = getuser()

    # TODO: why are we checking in /etc/group ?
    # Compare the pawprint to user groups
    with open('/etc/group', 'r') as fp:
        for line in fp:
            if USERNAME in line:
                break
        else:
            err_msg(
                'USER %s DID NOT EXIST IN ANY CLASS GROUP FOR THE SUMMER '
                'SEMESTER 2018!\nCONTACT YOUR TA TO RESOLVE THIS' % USERNAME)
            sys.exit()

    SESSIONS_FN = 'lab-sessions.json'
    HWS_FN = 'homeworks.json'

    if not file_exists(SESSIONS_FN):
        raise OSError('Lab sessions file does not exist: ' + SESSIONS_FN)
    if not file_exists(HWS_FN):
        raise OSError('Homework assignments file does not exist: ' + HWS_FN)

    setup_model()


def setup_model():
    global ADMIN_PASSWD, CURRENT_LAB, HWS, LAB_SESSIONS, LABS, MAKEUP, NUM_LABS

    # Defines ADMIN_PASSWD, NUM_LABS, and CURRENT_LAB
    with open('volatile', 'r') as volatile:
        exec(volatile.read(), globals(), globals())

    LABS = ['LAB_%d' % n for n in range(1, NUM_LABS+1)]
    MAKEUP = ['MAKEUP']

    # See the README file
    LAB_SESSIONS = []
    with open(SESSIONS_FN, 'r') as lab_sessions_f:
        for s in json.loads(lab_sessions_f.read()):
            letter = s['session'].upper()
            weekday = s['weekday']
            tp = TimePeriod(start=s['start'], end=s['end'])
            LAB_SESSIONS.append(LabSession(letter, weekday, tp))

    # See the README file
    HWS = []
    with open(HWS_FN, 'r') as hws_f:
        for hw in json.loads(hws_f.read()):
            dd = DueDate(hw['duedate'])
            HWS.append(Homework(hw['name'], dd))


# }}}


##################################################
# Functions and Classes For Checking Submit Time
##################################################


# {{{


def _check_time_lab():
    for session in LAB_SESSIONS:
        if WEEKDAY == session.weekday and NOW in session:
            break
    else:
        error(
            '\nAttempting to submit outside of specified lab time.\n'
            'Talk to your TA for further assistance.\n')


def _check_time_hw():
    if CURRENT_HW_END < NOW:
        error('\nAttempting to submit assignment past its due date.\n')


def check_time(isLab=False, isHw=False):
    if not isLab and not isHw:
        error('Can only check the time of a lab or homework assignment')
    if isLab:
        _check_time_lab()
    elif isHw:
        _check_time_hw()


# }}}


##################################################
# Admin Panel
##################################################


# {{{


def attempt_admin_login():
    """Return whether the entered password matches ADMIN_PASSWD."""
    return md5(getpass('Admin password: ')) == ADMIN_PASSWD


def admin_login():
    for n in range(3):
        if attempt_admin_login():
            break
        else:
            err_msg('Admin password incorrect')
    else:
        error('\nToo many invalid attempts')


def set_lab():
    """Change the CURRENT_LAB global variable.

    This function modifies this script's source code, replacing the old
    CURRENT_LAB value with the new one.
    """
    choice = listbox('Set the current lab', LABS)

    if choice is None:
        return

    modify_volatile('CURRENT_LAB', LABS[choice])


def change_num_labs():
    while True:
        try:
            new_num = int(input('How many lab assignments are there: '))
            if not 0 <= new_num:
                raise ValueError
            break
        except ValueError:
            err_msg('Input must be a positive integer')

    modify_volatile('NUM_LABS', new_num)


def modify_labs():
    def new_session():
        print()
        letter = get_session_letter()
        print()
        wd = get_weekday()
        print()
        start_hour = get_hour('Start hour (0..23): ')
        start_min = get_minute('Start minute (0..59): ')
        start_sec = get_second('Start second (0..59): ')
        print()
        end_hour = get_hour('End hour (0..23): ')
        end_min = get_minute('End minute (0..59): ')
        end_sec = get_second('End second (0..59): ')

        start = '%s:%s:%s' % (start_hour, start_min, start_sec)
        end = '%s:%s:%s' % (end_hour, end_min, end_sec)
        tp = TimePeriod(start=start, end=end)

        return LabSession(letter, wd, tp)

    def save_sessions(sessions):
        write_json(SESSIONS_FN, [{
            'session': s.letter.upper(),
            'weekday': s.weekday,
            'start': repr(s.start),
            'end': repr(s.end)
        } for s in sessions])

    menu('Modify Lab Sessions', LAB_SESSIONS, select_hook=new_session,
         add_hook=new_session, save_hook=save_sessions)


def modify_hws():
    def new_hw():
        print()
        name = get_hw_name()
        print()
        month = get_month()
        day = get_day(month)
        hour = get_hour('Hour (0..23): ')
        minute = get_minute('Minute (0..59): ')
        sec = get_second('Second (0..59): ')

        dd = DueDate('%s-%s-%sT%s:%s:%s' %
                     (NOW.year, month, day, hour, minute, sec))
        return Homework(name, dd)

    def save_hws(hws):
        write_json(HWS_FN, [{
            'name': hw.name,
            'duedate': repr(hw.duedate)
        } for hw in hws])

    menu('Modify Homework Due Dates', HWS, select_hook=new_hw,
         add_hook=new_hw, save_hook=save_hws)


def change_admin_passwd():
    new_passwd = getpass('New Admin Password: ')

    if new_passwd == '':
        error('Admin password cannot be empty')

    new_passwd2 = getpass('Repeat Password: ')

    if new_passwd != new_passwd2:
        err_msg('\nPasswords do not match')
        return

    modify_volatile('ADMIN_PASSWD', md5(new_passwd))


def admin_panel():
    main_choices = [
        'Set the current lab',
        'Change the number of lab assignments',
        'Modify lab sessions',
        'Modify homework assignments',
        'Change the admin password']

    while True:
        main_choice = listbox('Admin Panel', main_choices)
        print()

        if main_choice is None:
            return

        if main_choice == 0:
            set_lab()
        elif main_choice == 1:
            change_num_labs()
        elif main_choice == 2:
            modify_labs()
        elif main_choice == 3:
            modify_hws()
        elif main_choice == 4:
            change_admin_passwd()

        setup_model()


# }}}


##################################################
# Core Functions
##################################################


def download(fn):
    # XXX
    path = '/group/cs1050/debug2/' + fn
    path = './' + fn

    # Check that the file exists
    if not file_exists(path):
        error('File does not exist:', fn)

    # cp /group/cs1050/debug2/errors.c .
    if subprocess.check_call(['cp', path, '.']) != 0:
        error('Could not download file\nPlease notify your TA')


def submit(course, assignment, fn, override=None):
    # Check the assignment type
    hw_names = [hw.name for hw in HWS]
    if assignment not in LABS+hw_names+MAKEUP:
        err_msg('\nAssignment not recognized:', BOLD(assignment) + '\n')
        usage()

    if override is None:
        # Check if the assignment can be submitted now
        if assignment in LABS:
            check_time(isLab=True)
        elif assignment in HWS:
            check_time(isHw=True)
        elif assignment in MAKEUP:
            pass
    else:
        # Check that last arg is admin override sentinel
        if override != 'OVERRIDE':
            usage()
        print()
        admin_login()

    if not file_exists(fn):
        error('File does not exist:', fn)

    if not file_compiles(fn):
        error('File does not compile:', fn)

    # cp helloword.c /group/cs1050/submissions/LAB_1/jlz6w7_helloworld.c
    p = subprocess.Popen(
        # XXX
        # ['cp', fn, '/group/cs1050/submissions/%s/%s_%s'
        ['cp', fn, 'group/cs1050/submissions/%s/%s_%s'
            % (assignment, USERNAME, fn)], stderr=subprocess.PIPE)
    err = p.communicate()[1]
    if p.returncode != 0:
        print()
        err_msg(err.decode().strip())
        print()
        error('Could not submit assignment\nPlease notify your TA')


##################################################
# Main
##################################################


def main(args):
    # Prevent index error if no args were given
    if len(args) == 0:
        usage()

    setup()

    if args[0] == 'ADMIN':
        if len(args) != 1:
            usage()

        print()
        admin_login()

        admin_panel()

    # Submitting an assignment
    elif args[0] in ('CS1050', 'CS2050'):
        if len(args) not in (3, 4):
            usage()

        submit(*args)
        print('\nFile successfully submitted:', BOLD(sys.argv[2]) + '\n')

    # Downloading a file
    elif args[0] == 'DOWNLOAD':
        if len(args) != 2:
            usage()

        download(args[1])

    # First positional arg is invalid
    else:
        usage()


if __name__ == '__main__':
    main(sys.argv[1:])
